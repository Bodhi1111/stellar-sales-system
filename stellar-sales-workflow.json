[
    {
        "id": "lbKR1psB5LZcum4l",
        "name": "Stellar Sales System",
        "active": 1,
        "nodes": "[{\"parameters\":{\"triggerOn\":\"folder\",\"path\":\"/transcripts\",\"events\":[\"add\"],\"options\":{\"usePolling\":true}},\"id\":\"a55a19ba-eea6-4982-89bd-2d1264859c1b\",\"name\":\"File Watcher\",\"type\":\"n8n-nodes-base.localFileTrigger\",\"typeVersion\":1,\"position\":[-1312,-224],\"alwaysOutputData\":true,\"executeOnce\":false,\"retryOnFail\":true},{\"parameters\":{\"jsCode\":\"// Parse Transcript - Extract header metadata + structured dialogue\\n// Handles 3 header patterns + 2 dialogue patterns from parser_agent.py\\n\\nconst transcriptContent = $input.item.binary.data.toString('utf-8');\\nconst lines = transcriptContent.split('\\\\n');\\n\\n// ============================================================\\n// HEADER METADATA EXTRACTION (3 patterns)\\n// ============================================================\\n\\nfunction extractHeaderMetadata(lines) {\\n  const first20 = lines.slice(0, 20);\\n  \\n  const metadata = {\\n    meeting_title: null,\\n    client_name: null,\\n    client_email: null,\\n    meeting_date: null,\\n    meeting_time: null,\\n    transcript_id: null,\\n    meeting_url: null,\\n    duration_minutes: null\\n  };\\n  \\n  // Line 1 = meeting title (always)\\n  if (first20[0]) {\\n    metadata.meeting_title = first20[0].trim();\\n  }\\n  \\n  // Detect pattern\\n  const isPatternA = first20[1] && first20[1].trim() !== \\\"\\\";\\n  const isPatternC = (\\n    first20[1] && first20[1].trim() === \\\"\\\" &&\\n    first20[2] && first20[2].trim() === \\\"\\\" &&\\n    first20[3] && first20[3].includes('http')\\n  );\\n  \\n  if (isPatternA) {\\n    // PATTERN A: George Padron style (no blank after title)\\n    console.log('Detected Pattern A: George Padron style');\\n    metadata.client_name = first20[1] ? first20[1].trim() : null;\\n    metadata.client_email = (first20[3] && first20[3].includes('@')) ? first20[3].trim() : null;\\n    \\n    // Line 6: date + time\\n    if (first20[5]) {\\n      const dateMatch = first20[5].match(/(\\\\d{4}-\\\\d{2}-\\\\d{2})/);\\n      const timeMatch = first20[5].match(/T(\\\\d{2}:\\\\d{2}:\\\\d{2})/);\\n      metadata.meeting_date = dateMatch ? dateMatch[1] : null;\\n      metadata.meeting_time = timeMatch ? timeMatch[1] : null;\\n    }\\n    \\n    // Line 8: transcript_id\\n    if (first20[7]) {\\n      const idMatch = first20[7].match(/(\\\\d+\\\\.?\\\\d*)/);\\n      metadata.transcript_id = idMatch ? idMatch[1] : null;\\n    }\\n    \\n    // Line 10: URL\\n    metadata.meeting_url = (first20[9] && first20[9].includes('http')) ? first20[9].trim() : null;\\n    \\n    // Line 12: duration\\n    if (first20[11]) {\\n      const durMatch = first20[11].match(/(\\\\d+\\\\.?\\\\d*)/);\\n      metadata.duration_minutes = durMatch ? parseFloat(durMatch[1]) : null;\\n    }\\n    \\n  } else if (isPatternC) {\\n    // PATTERN C: Yongsik Johng style (double blank spacing)\\n    console.log('Detected Pattern C: Yongsik Johng style');\\n    metadata.meeting_url = first20[3] ? first20[3].trim() : null;\\n    \\n    // Line 7: date + time\\n    if (first20[6]) {\\n      const dateMatch = first20[6].match(/(\\\\d{4}-\\\\d{2}-\\\\d{2})/);\\n      const timeMatch = first20[6].match(/T(\\\\d{2}:\\\\d{2}:\\\\d{2})/);\\n      metadata.meeting_date = dateMatch ? dateMatch[1] : null;\\n      metadata.meeting_time = timeMatch ? timeMatch[1] : null;\\n    }\\n    \\n    // Line 10: duration\\n    if (first20[9]) {\\n      const durMatch = first20[9].match(/(\\\\d+\\\\.?\\\\d*)/);\\n      metadata.duration_minutes = durMatch ? parseFloat(durMatch[1]) : null;\\n    }\\n    \\n    // Line 13: client name\\n    metadata.client_name = first20[12] ? first20[12].trim() : null;\\n    \\n    // Line 16: email\\n    metadata.client_email = (first20[15] && first20[15].includes('@')) ? first20[15].trim() : null;\\n    \\n  } else {\\n    // PATTERN B: Robin Michalek style (single blank after title)\\n    console.log('Detected Pattern B: Robin Michalek style');\\n    metadata.client_name = first20[2] ? first20[2].trim() : null;\\n    metadata.client_email = (first20[4] && first20[4].includes('@')) ? first20[4].trim() : null;\\n    \\n    // Line 7: date + time\\n    if (first20[6]) {\\n      const dateMatch = first20[6].match(/(\\\\d{4}-\\\\d{2}-\\\\d{2})/);\\n      const timeMatch = first20[6].match(/T(\\\\d{2}:\\\\d{2}:\\\\d{2})/);\\n      metadata.meeting_date = dateMatch ? dateMatch[1] : null;\\n      metadata.meeting_time = timeMatch ? timeMatch[1] : null;\\n    }\\n    \\n    // Line 9: transcript_id (8-9 digit number)\\n    if (first20[8]) {\\n      const idMatch = first20[8].trim().match(/^(\\\\d{7,10})$/);\\n      metadata.transcript_id = idMatch ? idMatch[1] : null;\\n    }\\n    \\n    // Line 11: URL\\n    metadata.meeting_url = (first20[10] && first20[10].includes('http')) ? first20[10].trim() : null;\\n    \\n    // Line 13: duration\\n    if (first20[12]) {\\n      const durMatch = first20[12].match(/(\\\\d+\\\\.?\\\\d*)/);\\n      metadata.duration_minutes = durMatch ? parseFloat(durMatch[1]) : null;\\n    }\\n  }\\n  \\n  // Fallback: generate transcript_id from filename hash if not found\\n  if (!metadata.transcript_id) {\\n    const filename = $input.item.json.name || 'unknown';\\n    metadata.transcript_id = filename.replace(/\\\\D/g, '').slice(0, 8) || String(Date.now()).slice(-8);\\n  }\\n  \\n  return metadata;\\n}\\n\\n// ============================================================\\n// DIALOGUE PARSING (2 patterns)\\n// ============================================================\\n\\nfunction parseDialogue(lines) {\\n  const dialogue = [];\\n  \\n  // Pattern 1: Bracketed format [HH:MM:SS] Speaker: Text\\n  const bracketedPattern = /\\\\[(.*?)\\\\]\\\\s+([^:]+):\\\\s+(.*)/;\\n  \\n  // Try bracketed format first\\n  for (const line of lines) {\\n    const match = line.match(bracketedPattern);\\n    if (match) {\\n      dialogue.push({\\n        timestamp: match[1].trim(),\\n        speaker_name: match[2].trim(),\\n        text: match[3].trim()\\n      });\\n    }\\n  }\\n  \\n  // If no bracketed format found, try dashed format\\n  if (dialogue.length === 0) {\\n    const dashedPattern = /^\\\\s*(\\\\d{2}:\\\\d{2}:\\\\d{2})\\\\s+-\\\\s+(.+)$/;\\n    \\n    let i = 0;\\n    while (i < lines.length) {\\n      const line = lines[i];\\n      const match = line.match(dashedPattern);\\n      \\n      if (match) {\\n        const timestamp = match[1].trim();\\n        const speaker = match[2].trim();\\n        \\n        // Collect text from following indented lines\\n        const textLines = [];\\n        i++;\\n        \\n        while (i < lines.length) {\\n          const nextLine = lines[i];\\n          \\n          // Stop if we hit another timestamp\\n          if (nextLine.match(dashedPattern)) {\\n            break;\\n          }\\n          \\n          // Collect indented lines\\n          if (nextLine.startsWith('  ') && nextLine.trim()) {\\n            textLines.push(nextLine.trim());\\n          }\\n          \\n          i++;\\n        }\\n        \\n        if (textLines.length > 0) {\\n          dialogue.push({\\n            timestamp: timestamp,\\n            speaker_name: speaker,\\n            text: textLines.join(' ')\\n          });\\n        }\\n        \\n        continue;\\n      }\\n      \\n      i++;\\n    }\\n  }\\n  \\n  return dialogue;\\n}\\n\\n// ============================================================\\n// MAIN EXECUTION\\n// ============================================================\\n\\nconst headerMetadata = extractHeaderMetadata(lines);\\nconst structuredDialogue = parseDialogue(lines);\\n\\nconsole.log(`Parsed ${structuredDialogue.length} dialogue turns`);\\nconsole.log(`Header metadata:`, JSON.stringify(headerMetadata, null, 2));\\n\\nreturn {\\n  json: {\\n    header_metadata: headerMetadata,\\n    structured_dialogue: structuredDialogue,\\n    transcript_id: headerMetadata.transcript_id,\\n    filename: $input.item.json.name\\n  }\\n};\"},\"id\":\"03f62edf-8b47-4cdb-91bc-cf61c39fbb19\",\"name\":\"Parse Transcript\",\"type\":\"n8n-nodes-base.code\",\"typeVersion\":2,\"position\":[-912,-224]},{\"parameters\":{\"jsCode\":\"// Semantic Chunker - Parent-Child Hierarchy\\n// Based on semantic_chunker.py\\n\\nconst { structured_dialogue, transcript_id } = $input.item.json;\\n\\nif (!structured_dialogue || structured_dialogue.length === 0) {\\n  return { json: { child_chunks: [], parent_chunks: [], all_chunks: [], header_chunk: null } };\\n}\\n\\n// ============================================================\\n// CONFIGURATION\\n// ============================================================\\n\\nconst TURNS_PER_PARENT = 7;\\nconst MIN_TURNS_PER_PARENT = 5;\\nconst MAX_TURNS_PER_PARENT = 10;\\n\\n// ============================================================\\n// HELPER FUNCTIONS\\n// ============================================================\\n\\nfunction generateUUID() {\\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\\n    const r = Math.random() * 16 | 0;\\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\\n    return v.toString(16);\\n  });\\n}\\n\\nfunction timestampToSeconds(timestamp) {\\n  try {\\n    const parts = timestamp.split(':');\\n    if (parts.length === 3) {\\n      return parseFloat(parts[0]) * 3600 + parseFloat(parts[1]) * 60 + parseFloat(parts[2]);\\n    }\\n    return 0.0;\\n  } catch (e) {\\n    return 0.0;\\n  }\\n}\\n\\nfunction extractTopics(text) {\\n  const keywords = [\\n    'estate planning', 'trust', 'will', 'power of attorney',\\n    'healthcare directive', 'beneficiary', 'executor', 'trustee',\\n    'probate', 'asset protection', 'tax planning', 'inheritance',\\n    'revocable', 'irrevocable', 'living trust', 'testamentary',\\n    'guardianship', 'conservatorship', 'real estate', 'property',\\n    'children', 'spouse', 'family', 'divorce', 'marriage',\\n    'business', 'LLC', 'corporation', 'partnership',\\n    'retirement', 'IRA', '401k', 'pension', 'investment',\\n    'debt', 'creditor', 'lawsuit', 'medicaid', 'nursing home',\\n    'price', 'cost', 'fee', 'payment', 'deposit', 'financing'\\n  ];\\n  \\n  const textLower = text.toLowerCase();\\n  const detected = [];\\n  \\n  for (const keyword of keywords) {\\n    if (textLower.includes(keyword)) {\\n      detected.push(keyword);\\n    }\\n  }\\n  \\n  return detected.slice(0, 5); // Top 5 topics\\n}\\n\\nfunction phaseToSalesStage(conversationPhase) {\\n  if (!conversationPhase) return 'Unknown';\\n  \\n  const phase = conversationPhase.toLowerCase();\\n  \\n  if (phase.includes('setting up') || phase.includes('pre-meeting')) return 'Setting up for meeting';\\n  if (phase.includes('assistant intro') || phase.includes('rep intro')) return 'Assistant Intro Rep';\\n  if (phase.includes('greeting') || phase.includes('hello') || phase.includes('introduction')) return 'Greeting';\\n  if (phase.includes('motivation') || phase.includes('why')) return 'Client Motivation';\\n  if (phase.includes('agenda') || phase.includes('plan')) return 'Set Meeting Agenda';\\n  if (phase.includes('credibility') || phase.includes('about us') || phase.includes('experience')) return 'Establish Credibility';\\n  if (phase.includes('discovery') || phase.includes('needs') || phase.includes('goals') || phase.includes('estate details')) return 'Discovery';\\n  if (phase.includes('compare') || phase.includes('options') || phase.includes('competition')) return 'Compare Options';\\n  if (phase.includes('present') || phase.includes('solution') || phase.includes('structure') || phase.includes('benefits')) return 'Present Solution';\\n  if (phase.includes('pric') || phase.includes('cost') || phase.includes('fee') || phase.includes('money')) return 'Pricing';\\n  if (phase.includes('objection') || phase.includes('rebuttal') || phase.includes('concern')) return 'Objection Handling';\\n  if (phase.includes('closing') || phase.includes('close') || phase.includes('ending') || phase.includes('scheduling')) return 'Closing';\\n  \\n  return 'Unknown';\\n}\\n\\n// ============================================================\\n// CREATE CHILD CHUNKS (1 speaker turn = 1 child chunk)\\n// ============================================================\\n\\nfunction createChildChunks(dialogue, externalId) {\\n  const childChunks = [];\\n  \\n  for (let idx = 0; idx < dialogue.length; idx++) {\\n    const turn = dialogue[idx];\\n    const chunkId = generateUUID();\\n    \\n    const timestampStr = turn.timestamp || '00:00:00';\\n    const startTime = timestampToSeconds(timestampStr);\\n    \\n    // Estimate end time\\n    let endTime;\\n    if (idx + 1 < dialogue.length) {\\n      endTime = timestampToSeconds(dialogue[idx + 1].timestamp || '00:00:00');\\n    } else {\\n      endTime = startTime + 15.0; // Default 15 second turn\\n    }\\n    \\n    const detectedTopics = extractTopics(turn.text || '');\\n    const conversationPhase = turn.conversation_phase || 'unknown';\\n    const salesStage = phaseToSalesStage(conversationPhase);\\n    \\n    childChunks.push({\\n      chunk_id: chunkId,\\n      parent_id: null, // Assigned later\\n      chunk_type: 'child',\\n      external_id: externalId,\\n      text: turn.text || '',\\n      speaker_name: turn.speaker_name || 'Unknown',\\n      start_time: startTime,\\n      end_time: endTime,\\n      sales_stage: salesStage,\\n      conversation_phase: conversationPhase,\\n      detected_topics: detectedTopics,\\n      intent: turn.intent || null,\\n      sentiment: turn.sentiment || null,\\n      discourse_marker: turn.discourse_marker || null,\\n      contains_entity: turn.contains_entity || false,\\n      timestamp: timestampStr,\\n      turn_index: idx\\n    });\\n  }\\n  \\n  return childChunks;\\n}\\n\\n// ============================================================\\n// CREATE PARENT CHUNKS (group 5-10 children)\\n// ============================================================\\n\\nfunction groupChildrenIntoParents(children) {\\n  const groups = [];\\n  let currentGroup = [];\\n  \\n  for (const child of children) {\\n    currentGroup.push(child);\\n    \\n    if (currentGroup.length >= TURNS_PER_PARENT) {\\n      groups.push(currentGroup);\\n      currentGroup = [];\\n    }\\n  }\\n  \\n  // Handle final group\\n  if (currentGroup.length > 0) {\\n    if (currentGroup.length < MIN_TURNS_PER_PARENT && groups.length > 0) {\\n      // Merge with last group\\n      groups[groups.length - 1] = groups[groups.length - 1].concat(currentGroup);\\n    } else {\\n      groups.push(currentGroup);\\n    }\\n  }\\n  \\n  return groups;\\n}\\n\\nfunction buildParentFromChildren(children, externalId) {\\n  const parentId = generateUUID();\\n  \\n  // Aggregate text\\n  const parentText = children.map(c => \\n    `[${c.timestamp}] ${c.speaker_name}: ${c.text}`\\n  ).join('\\\\n');\\n  \\n  // Aggregate metadata\\n  const timestamps = children.map(c => c.timestamp);\\n  const speakers = children.map(c => c.speaker_name);\\n  const uniqueSpeakers = [...new Set(speakers)];\\n  \\n  // Speaker balance\\n  const clientKeywords = ['client', 'iphone', 'caller'];\\n  const clientTurns = speakers.filter(s => \\n    clientKeywords.some(kw => s.toLowerCase().includes(kw))\\n  ).length;\\n  const speakerBalance = speakers.length > 0 ? clientTurns / speakers.length : 0.5;\\n  \\n  // Most common phase\\n  const phases = children\\n    .map(c => c.conversation_phase)\\n    .filter(p => p && p !== 'unknown');\\n  \\n  let conversationPhase = 'unknown';\\n  if (phases.length > 0) {\\n    // Find mode (most common)\\n    const phaseCount = {};\\n    phases.forEach(p => phaseCount[p] = (phaseCount[p] || 0) + 1);\\n    conversationPhase = Object.keys(phaseCount).reduce((a, b) => \\n      phaseCount[a] > phaseCount[b] ? a : b\\n    );\\n  }\\n  \\n  const salesStage = phaseToSalesStage(conversationPhase);\\n  \\n  // Aggregate topics\\n  const allTopics = [];\\n  children.forEach(c => {\\n    if (c.detected_topics && Array.isArray(c.detected_topics)) {\\n      allTopics.push(...c.detected_topics);\\n    }\\n  });\\n  const detectedTopics = [...new Set(allTopics)].slice(0, 10);\\n  \\n  return {\\n    chunk_id: parentId,\\n    parent_id: null,\\n    chunk_type: 'parent',\\n    external_id: externalId,\\n    text: parentText,\\n    conversation_phase: conversationPhase,\\n    sales_stage: salesStage,\\n    detected_topics: detectedTopics,\\n    timestamp_start: timestamps[0] || null,\\n    timestamp_end: timestamps[timestamps.length - 1] || null,\\n    start_time: children[0].start_time,\\n    end_time: children[children.length - 1].end_time,\\n    turn_count: children.length,\\n    speaker_balance: Math.round(speakerBalance * 100) / 100,\\n    speakers: uniqueSpeakers,\\n    child_chunk_ids: children.map(c => c.chunk_id)\\n  };\\n}\\n\\nfunction createParentChunks(childChunks, externalId) {\\n  const parentGroups = groupChildrenIntoParents(childChunks);\\n  const parentChunks = parentGroups.map(group => \\n    buildParentFromChildren(group, externalId)\\n  );\\n  return parentChunks;\\n}\\n\\n// ============================================================\\n// LINK CHILDREN TO PARENTS\\n// ============================================================\\n\\nfunction linkChildrenToParents(childChunks, parentChunks) {\\n  // Build mapping: child_id -> parent_id\\n  const childToParent = {};\\n  \\n  for (const parent of parentChunks) {\\n    for (const childId of parent.child_chunk_ids) {\\n      childToParent[childId] = parent.chunk_id;\\n    }\\n  }\\n  \\n  // Update children with parent_id\\n  for (const child of childChunks) {\\n    child.parent_id = childToParent[child.chunk_id] || null;\\n  }\\n}\\n\\n// ============================================================\\n// CREATE HEADER CHUNK\\n// ============================================================\\n\\nfunction createHeaderChunk(headerMetadata, externalId) {\\n  const headerText = [\\n    `Meeting: ${headerMetadata.meeting_title || 'Unknown'}`,\\n    `Client: ${headerMetadata.client_name || 'Unknown'}`,\\n    `Email: ${headerMetadata.client_email || 'Not provided'}`,\\n    `Date: ${headerMetadata.meeting_date || 'Unknown'}`,\\n    `Time: ${headerMetadata.meeting_time || 'Unknown'}`,\\n    `Duration: ${headerMetadata.duration_minutes || 0} minutes`,\\n    `ID: ${headerMetadata.transcript_id || 'Unknown'}`\\n  ].join('\\\\n');\\n  \\n  return {\\n    chunk_id: generateUUID(),\\n    parent_id: null,\\n    chunk_type: 'header',\\n    external_id: externalId,\\n    text: headerText,\\n    conversation_phase: null,\\n    sales_stage: null,\\n    detected_topics: [],\\n    timestamp_start: null,\\n    timestamp_end: null,\\n    start_time: 0,\\n    end_time: 0,\\n    turn_count: 0,\\n    speaker_balance: null,\\n    speakers: []\\n  };\\n}\\n\\n// ============================================================\\n// MAIN EXECUTION\\n// ============================================================\\n\\nconst externalId = transcript_id;\\nconst headerMetadata = $input.item.json.header_metadata || {};\\n\\n// Step 1: Create child chunks (1 turn = 1 chunk)\\nconst childChunks = createChildChunks(structured_dialogue, externalId);\\nconsole.log(`Created ${childChunks.length} child chunks`);\\n\\n// Step 2: Create parent chunks (group 5-10 children)\\nconst parentChunks = createParentChunks(childChunks, externalId);\\nconsole.log(`Created ${parentChunks.length} parent chunks`);\\n\\n// Step 3: Link children to parents\\nlinkChildrenToParents(childChunks, parentChunks);\\nconsole.log('Linked children to parents');\\n\\n// Step 4: Create header chunk\\nconst headerChunk = createHeaderChunk(headerMetadata, externalId);\\nconsole.log('Created header chunk');\\n\\n// Combine all chunks for Baserow sync\\nconst allChunks = [headerChunk, ...parentChunks, ...childChunks];\\n\\nreturn {\\n  json: {\\n    child_chunks: childChunks,\\n    parent_chunks: parentChunks,\\n    header_chunk: headerChunk,\\n    all_chunks: allChunks,\\n    transcript_id: externalId,\\n    header_metadata: headerMetadata\\n  }\\n};\"},\"id\":\"59595700-80dc-4ea7-947e-208e21318428\",\"name\":\"Semantic Chunker\",\"type\":\"n8n-nodes-base.code\",\"typeVersion\":2,\"position\":[-720,-224]},{\"parameters\":{\"method\":\"POST\",\"url\":\"http://host.docker.internal:8000/embeddings\",\"sendBody\":true,\"bodyParameters\":{\"parameters\":[{\"name\":\"text\",\"value\":\"={{ $json.text }}\"}]},\"options\":{}},\"id\":\"79686b47-78f6-48bb-85ef-f536027faee8\",\"name\":\"Generate Embeddings\",\"type\":\"n8n-nodes-base.httpRequest\",\"typeVersion\":4.1,\"position\":[-304,-384]},{\"parameters\":{\"options\":{}},\"id\":\"dff9dbaa-a97a-4940-a088-c752cc84d2ef\",\"name\":\"Combine Chunk + Embedding\",\"type\":\"n8n-nodes-base.set\",\"typeVersion\":3.2,\"position\":[-96,-384]},{\"parameters\":{\"url\":\"http://localhost:6333/collections/transcripts/points/upsert\",\"authentication\":\"genericCredentialType\",\"sendBody\":true,\"bodyParameters\":{\"parameters\":[{}]},\"options\":{}},\"id\":\"6af08ef7-dddf-4bb0-9be5-430d1439cd3a\",\"name\":\"Store Child Chunks in Qdrant\",\"type\":\"n8n-nodes-base.httpRequest\",\"typeVersion\":4.1,\"position\":[80,-384]},{\"parameters\":{\"url\":\"http://localhost:6333/collections/transcripts/points/upsert\",\"sendBody\":true,\"bodyParameters\":{\"parameters\":[{}]},\"options\":{}},\"id\":\"2ced0ef9-117e-4a95-a967-601033b22bdd\",\"name\":\"Store Parent Chunks in Qdrant\",\"type\":\"n8n-nodes-base.httpRequest\",\"typeVersion\":4.1,\"position\":[96,-112]},{\"parameters\":{\"options\":{}},\"id\":\"478583d2-d55f-4d12-92d4-f508a2e54204\",\"name\":\"Setup RAG Categories\",\"type\":\"n8n-nodes-base.set\",\"typeVersion\":3.2,\"position\":[304,-224]},{\"parameters\":{\"options\":{}},\"id\":\"5e72247d-2b04-4620-9efd-2f633b1dc955\",\"name\":\"Loop RAG Categories\",\"type\":\"n8n-nodes-base.splitInBatches\",\"typeVersion\":3,\"position\":[496,-224]},{\"parameters\":{\"url\":\"http://localhost:6333/collections/transcripts/points/search\",\"sendBody\":true,\"bodyParameters\":{\"parameters\":[{}]},\"options\":{}},\"id\":\"fd28a65d-646c-4122-a15f-5b6f6c881e41\",\"name\":\"Qdrant Search\",\"type\":\"n8n-nodes-base.httpRequest\",\"typeVersion\":4.1,\"position\":[704,-224]},{\"parameters\":{\"jsCode\":\"// Aggregate RAG results into final CRM object\\n\\nconst categories = $input.all();\\nconst headerMetadata = $('Semantic Chunker').item.json.header_metadata;\\nconst transcriptId = $('Semantic Chunker').item.json.transcript_id;\\n\\n// Initialize CRM object with header metadata\\nconst crmData = {\\n  transcript_id: transcriptId,\\n  client_name: headerMetadata.client_name || 'Unknown',\\n  client_email: headerMetadata.client_email || '',\\n  meeting_date: headerMetadata.meeting_date || '',\\n  meeting_time: headerMetadata.meeting_time || '',\\n  meeting_title: headerMetadata.meeting_title || '',\\n  duration_minutes: headerMetadata.duration_minutes || 0,\\n  marital_status: '',\\n  children_count: 0,\\n  estate_value: 0,\\n  real_estate_count: 0,\\n  product_discussed: '',\\n  deal: 0,\\n  deposit: 0,\\n  outcome: 'Pending',\\n  win_probability: 0.5,\\n  close_date: '',\\n  objections_raised: '',\\n  action_items: '',\\n  transcript_summary: '',\\n  follow_up_email_draft: '',\\n  social_media_quote: '',\\n  coaching_opportunities: ''\\n};\\n\\n// Merge extracted data from each category\\nfor (const category of categories) {\\n  if (category.json && category.json.extracted_data) {\\n    Object.assign(crmData, category.json.extracted_data);\\n  }\\n}\\n\\nreturn { json: { crm_data: crmData } };\"},\"id\":\"dd2d1a7a-1a20-4985-a6a7-42bae82fe96b\",\"name\":\"Aggregate CRM Data\",\"type\":\"n8n-nodes-base.code\",\"typeVersion\":2,\"position\":[1104,-224]},{\"parameters\":{\"url\":\"http://localhost:8080/api/database/rows/table/{{ $env.BASEROW_CLIENTS_ID }}/?user_field_names=true\",\"authentication\":\"genericCredentialType\",\"genericAuthType\":\"httpHeaderAuth\",\"sendHeaders\":true,\"headerParameters\":{\"parameters\":[{\"name\":\"Authorization\",\"value\":\"Token {{ $env.BASEROW_TOKEN }}\"}]},\"sendBody\":true,\"bodyParameters\":{\"parameters\":[{}]},\"options\":{}},\"id\":\"7b588e88-1630-422b-9594-f912853e989f\",\"name\":\"Sync to Baserow - Clients\",\"type\":\"n8n-nodes-base.httpRequest\",\"typeVersion\":4.1,\"position\":[1296,-544]},{\"parameters\":{\"url\":\"http://localhost:8080/api/database/rows/table/{{ $env.BASEROW_MEETINGS_ID }}/?user_field_names=true\",\"authentication\":\"genericCredentialType\",\"genericAuthType\":\"httpHeaderAuth\",\"sendHeaders\":true,\"headerParameters\":{\"parameters\":[{\"name\":\"Authorization\",\"value\":\"Token {{ $env.BASEROW_TOKEN }}\"}]},\"sendBody\":true,\"bodyParameters\":{\"parameters\":[{}]},\"options\":{}},\"id\":\"230070e7-2366-4a20-a152-1a45e6c54e4b\",\"name\":\"Sync to Baserow - Meetings\",\"type\":\"n8n-nodes-base.httpRequest\",\"typeVersion\":4.1,\"position\":[1296,-368]},{\"parameters\":{\"url\":\"http://localhost:8080/api/database/rows/table/{{ $env.BASEROW_DEALS_ID }}/?user_field_names=true\",\"authentication\":\"genericCredentialType\",\"genericAuthType\":\"httpHeaderAuth\",\"sendHeaders\":true,\"headerParameters\":{\"parameters\":[{\"name\":\"Authorization\",\"value\":\"Token {{ $env.BASEROW_TOKEN }}\"}]},\"sendBody\":true,\"bodyParameters\":{\"parameters\":[{}]},\"options\":{}},\"id\":\"4b454295-e1c0-4f56-8d93-7c2145b0db54\",\"name\":\"Sync to Baserow - Deals\",\"type\":\"n8n-nodes-base.httpRequest\",\"typeVersion\":4.1,\"position\":[1296,-224]},{\"parameters\":{\"url\":\"http://localhost:8080/api/database/rows/table/{{ $env.BASEROW_COMMUNICATIONS_ID }}/?user_field_names=true\",\"authentication\":\"genericCredentialType\",\"genericAuthType\":\"httpHeaderAuth\",\"sendHeaders\":true,\"headerParameters\":{\"parameters\":[{\"name\":\"Authorization\",\"value\":\"Token {{ $env.BASEROW_TOKEN }}\"}]},\"sendBody\":true,\"bodyParameters\":{\"parameters\":[{}]},\"options\":{}},\"id\":\"cf0278ba-5f90-4e0c-aed8-7fe21e880132\",\"name\":\"Sync to Baserow - Communications\",\"type\":\"n8n-nodes-base.httpRequest\",\"typeVersion\":4.1,\"position\":[1296,-64]},{\"parameters\":{\"url\":\"http://localhost:8080/api/database/rows/table/{{ $env.BASEROW_SALES_COACHING_ID }}/?user_field_names=true\",\"authentication\":\"genericCredentialType\",\"genericAuthType\":\"httpHeaderAuth\",\"sendHeaders\":true,\"headerParameters\":{\"parameters\":[{\"name\":\"Authorization\",\"value\":\"Token {{ $env.BASEROW_TOKEN }}\"}]},\"sendBody\":true,\"bodyParameters\":{\"parameters\":[{}]},\"options\":{}},\"id\":\"74dc1d76-b072-43f2-810d-c3e795f5bc8a\",\"name\":\"Sync to Baserow - Coaching\",\"type\":\"n8n-nodes-base.httpRequest\",\"typeVersion\":4.1,\"position\":[1296,128]},{\"parameters\":{\"mode\":\"combine\",\"combinationMode\":\"multiplex\",\"options\":{}},\"id\":\"282edea2-11ad-4fde-a876-06ac7a456a14\",\"name\":\"Sync Complete\",\"type\":\"n8n-nodes-base.merge\",\"typeVersion\":2.1,\"position\":[1504,-224]},{\"parameters\":{\"filePath\":\"={{ $json.path }}\"},\"id\":\"a252fb65-a6b7-4d46-af32-488e671b3e03\",\"name\":\"Read Transcript File1\",\"type\":\"n8n-nodes-base.readBinaryFile\",\"typeVersion\":1,\"position\":[-1120,-224]},{\"parameters\":{\"options\":{}},\"type\":\"n8n-nodes-base.splitInBatches\",\"typeVersion\":3,\"position\":[-512,-224],\"id\":\"0cc33053-dc77-4768-9561-b5863b70c5e1\",\"name\":\"Loop Over Items\"},{\"parameters\":{},\"type\":\"n8n-nodes-base.noOp\",\"name\":\"Replace Me\",\"typeVersion\":1,\"position\":[-304,-224],\"id\":\"2a8f81a6-1511-4e71-82f2-63c706cb91b1\"}]",
        "connections": "{\"File Watcher\":{\"main\":[[{\"node\":\"Read Transcript File1\",\"type\":\"main\",\"index\":0}]]},\"Parse Transcript\":{\"main\":[[{\"node\":\"Semantic Chunker\",\"type\":\"main\",\"index\":0}]]},\"Semantic Chunker\":{\"main\":[[{\"node\":\"Store Parent Chunks in Qdrant\",\"type\":\"main\",\"index\":0},{\"node\":\"Setup RAG Categories\",\"type\":\"main\",\"index\":0},{\"node\":\"Loop Over Items\",\"type\":\"main\",\"index\":0}]]},\"Generate Embeddings\":{\"main\":[[{\"node\":\"Combine Chunk + Embedding\",\"type\":\"main\",\"index\":0}]]},\"Combine Chunk + Embedding\":{\"main\":[[{\"node\":\"Store Child Chunks in Qdrant\",\"type\":\"main\",\"index\":0}]]},\"Setup RAG Categories\":{\"main\":[[{\"node\":\"Loop RAG Categories\",\"type\":\"main\",\"index\":0}]]},\"Loop RAG Categories\":{\"main\":[[{\"node\":\"Qdrant Search\",\"type\":\"main\",\"index\":0}],[{\"node\":\"Aggregate CRM Data\",\"type\":\"main\",\"index\":0}]]},\"Aggregate CRM Data\":{\"main\":[[{\"node\":\"Sync to Baserow - Clients\",\"type\":\"main\",\"index\":0},{\"node\":\"Sync to Baserow - Meetings\",\"type\":\"main\",\"index\":0},{\"node\":\"Sync to Baserow - Deals\",\"type\":\"main\",\"index\":0},{\"node\":\"Sync to Baserow - Communications\",\"type\":\"main\",\"index\":0},{\"node\":\"Sync to Baserow - Coaching\",\"type\":\"main\",\"index\":0}]]},\"Sync to Baserow - Clients\":{\"main\":[[{\"node\":\"Sync Complete\",\"type\":\"main\",\"index\":0}]]},\"Sync to Baserow - Meetings\":{\"main\":[[{\"node\":\"Sync Complete\",\"type\":\"main\",\"index\":1}]]},\"Read Transcript File1\":{\"main\":[[{\"node\":\"Parse Transcript\",\"type\":\"main\",\"index\":0}]]},\"Loop Over Items\":{\"main\":[[{\"node\":\"Generate Embeddings\",\"type\":\"main\",\"index\":0}],[{\"node\":\"Replace Me\",\"type\":\"main\",\"index\":0}]]},\"Replace Me\":{\"main\":[[{\"node\":\"Loop Over Items\",\"type\":\"main\",\"index\":0}]]}}",
        "settings": "{\"executionOrder\":\"v1\"}",
        "staticData": "{\"node:Check Every 30 Seconds\":{\"recurrenceRules\":[]}}",
        "pinData": "{}",
        "versionId": "ba07f319-fdfa-4a28-aa23-b60e4ee7ae75",
        "triggerCount": 1,
        "meta": null,
        "parentFolderId": null,
        "createdAt": "2025-10-14 00:24:25.723",
        "updatedAt": "2025-10-15 02:32:08",
        "isArchived": 0
    }
]
